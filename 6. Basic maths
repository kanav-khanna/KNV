
Prime numbers (number with only 2 factors)
Ways of finding prime number - 
1.naive approch - if n = 10 then loop from 1 to 9 -> (n%i) == 0 ..then not prime else prime 
2.sqrt approch  - factor will exist in less than root n ....it will always exist in less than root  n 
3.sieve of eratosthenes
4.segmented sieve

https://leetcode.com/problems/count-primes/description/
1. naieve //TLE issue 
TC- O(n^2)

class Solution {
public:

    bool isprime(int n)
        {
            if(n<=1)
                {
                    return false;
                }
            
            for(int i =2;i<n;i++)
                {
                    if(n%i==0)
                        {
                            return false;
                        }
                }
            return true;
            
        }
    int countPrimes(int n) {
        int count =0;

        for(int i=0;i<n;i++)
            {
                if(isprime(i))
                    {
                        count++;
                    }
            }
        return count;
    }
};

///sqrt this also has TLE fail 
class Solution {
public:

    bool isprime(int n)
        {   
            int sqrtn = sqrt(n);
            if(n<=1)
                {
                    return false;
                }
            
            for(int i =2;i<sqrtn;i++)
                {
                    if(n%i==0)
                        {
                            return false;
                        }
                }
            return true;
            
        }
    int countPrimes(int n) {
        int count =0;

        for(int i=0;i<n;i++)
            {
                if(isprime(i))
                    {
                        count++;
                    }
            }
        return count;
    }
};

3.sieve of eratosthenes 
TC-    O(n*log(log n))


in this we crate a vector with everything marked as prime 
then we run a loop start from 2
the loop will run and do ans++ for each element marken true 
and then it will 

class Solution {
public:


    int countPrimes(int n) {
        if(n ==0) return 0;

        vector<bool> prime(n,true);
        prime[0] = prime[1] = false;

        int ans = 0;

        for(int i =2;i<n;i++)
            {
                if(prime[i])
                    {
                        ans++;
                    }
                int j =2*i;
                while(j<n){
                    prime[j] = false;
                    j+=i;
                }
            }
        return ans;
    }
};

///4.segmented sieve
similar to the above one ..this is used when low or high is given 


/////////////////////////////////////////////
Gratest common devisor/Highest common factor
GCD/HDF

1.euclids algorithm  gcd(a,b) = gcd(a-b,b) or GCD(A%B,b);
2.LCM
(a,b)*gcd(a,b) =a*b;

////////////////

we will use these formulas 
GCD(a-b,b) A>B //apply this till ojne of the paramenter becomes 0 
GCD(b-a,a) A<B

https://www.geeksforgeeks.org/problems/gcd-of-two-numbers3459/1

    int gcd(int a, int b) {
        // code here
        if(a == 0) return b;
        
        if(b == 0) return a;
        
        
        while(a>0&&b>0){
            if(a>b)
                {
                    a = a-b; //euclids algorithm
                }
            
            else
                {
                    b = b-a;
                }
        }
        
        return a==0 ?b:a;
    }
};

//////////////////////LCM
lcm = (a*b)/GCD



////////MODULO arithmetic 

Generally to avoid overflow while storing integer we use modulo with a large number 

1. (a+b)%M = a%m+b%M
2. a%M -b = (a-b) %m
3. ((a%M)%m)%M = a%m
4. a%M*b%M  = (a*b)%m

////////FAST exponentiation 
normal way of finding a to the power b a^b  has time complexity O(b)
better way a^b TC - O(log b)


better code - 

while(b>0)
    {
        if(b&1)
            {   //off number 
                ans = ans*a;
            }

            a = a*a; 
            b>>=1; //this means b/2

    }
    return ans 



/////////Modular Exponentiation for large numbers
https://www.geeksforgeeks.org/problems/modular-exponentiation-for-large-numbers5537/1
   long long int PowMod(long long int x, long long int n, long long int M) {
        // Code here
        long long int ans = 1;
        while(n>0)
            {
                if(n&1)
                {
                    ans = (ans*x)%M;
                }
                x=(x*x)%M;
                n>>=1;
            }
    
        return ans;
    }
};